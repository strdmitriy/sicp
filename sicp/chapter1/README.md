#Краткий обзор книги СИКП находится в проработке и еще не закончен
# Краткий обзор основных идей

## 1.1 Элементы программирования
* Каждый язык программирования имеет 3 составляющие с помощью которых мы можем комбинировать простые идеи и создавать с   их помощью сложные.

1. Элементарные выражения
    * Минимальные сущности к которым относятся числа и арифметические операция.
2. Средства комбинирования
    * Вложенные комбинации.
3. Средства абстракций
    * Служат для упрощения сложных идей. Вспоминаем книгу "Совершенный КОД" и главный технический императив разработки ПО - управление сложностью, абстракиция является одним из главных способов борьбы с ней.

## 1.1.2 Имена и окружения
* Одна из важнейших характеристик языка программирования - возможность использовать имена для указания на                 вычислительные объекты. Если говорить простым языком - это создание переменных.
  В диалекте Лисп мы задаем переменную с помощью слова **define**. Например **(define size 2)** - это заставить итерпритатор связать значение **2** с именем **size**.

* Переменные служат простейшим стредством абстрации, что позволяет нам оперировать простыми именеми для обозначения сложных операция.

## 1.1.4 Составные процедуры
* Определение процедур - значительно более мощный метод абстракций с помощью которой составной операции можно дать имя и ссылаться на нее как на единое целое. В главе идет речь о создании функции с определенным набором действий. Определение процедуры имеет вид: **(define (<имя> <парметры>) <тело>)**. С помощью процед мы можем составлять более сложные конструкции используя простые процедуры. Как пример мы можем определить процеду нахождения квадрата, и вызывать ее в другой процедуре, которая ищет сумму квадратов.
```(define ( square x) * x x)

   (define (sum-of-squares x y)
    (+ (square x) (square y)))    
```

## 1.1.5 Подстановочная модель применения процедур
* Приоткроем тайну того, как интерпритатор вычисляет составную процедуру (в дальнейших главах раскроем тайну полностью). Рассмотрим 2 вида вычислений.
### Нормальный порядок вычислений
Интерпритатору нужно вычислить оператор, процедуру и операнды. Сначала вычисляется оператор и восстанавливается тело процедуры, дальше мы вычисляем операнды и подставляем их в аргументы. Что происходит: имея процедуру  
```
(define (fn a)
(sum-of-squares (+ a 1) (* 2)))

(fn 5)
```
Что делает интерпритатор? Он вычисляет операторы т.е восстанавливает тело **fn**, дальше мы вычисляем операнды заменяя параметр **a** на аргумент 5 и восстанавливаем тело процедуры sum-of-squares и подставляем в элементарные процедуры параметры
```fn = (sum-of-squares (+ a 1) (* 2)) = (+ (square 6) (square 10)) = (+ (6 * 6) (10 * 10))```
### Аппликативный порядок вычислений
* Вычисления происходят почти точно так же, но подстановка происходит только в тот момент, когда эти вычисления понадобяться. Аппликативный порядок - ленивые вычисления.